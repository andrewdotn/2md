#!/usr/bin/env node -r ./babel-register

import { join as joinPath, parse } from "path";
import { readFile, writeFile } from "fs-extra";
import { inspect } from "util";
import remark from "remark";
import html from "remark-html";
import { format } from "prettier/standalone";
import { sortBy } from "lodash";
import prettierBabelPlugin from "prettier/parser-babylon";
// This file is using the babel settings for a browser
import "regenerator-runtime";
import { renderToStaticMarkup } from "react-dom/server";
import React from "react";

export type Fixture =
  | {
      title: string;
      sourceUrl: string;
      author: string;
      authorUrl: string;
      licenseName: string;
      html: string;
    }
  | { html: string; title: string };

function unslug(s: string) {
  s = parse(s).name;

  s = s
    .split("-")
    .map(s => s.toLowerCase())
    .join(" ");
  s = s[0].toUpperCase() + s.slice(1);
  return s;
}

export async function main() {
  const targetFile = joinPath(__dirname, "..", "src", "generated-fixtures.ts");

  let fixtures: Fixture[] = [];

  fixtures.push({
    title: "Hello world",
    html: renderToStaticMarkup(
      <div>
        {/*
            With content-editable, sometimes doing select-all, then paste, was
            pasting into the <h3> node, causing badly messed-up markdown output.
            By having a <p> first it doesn’t look as nice but we skip that bug.
        */}
        <p className="mb-1">Welcome</p>
        <h3 className="">Input</h3>
        <p>
          Paste <i>formatted</i> text here to see it turned into Markdown.
        </p>
      </div>
    )
  });

  for (const path of [
    "2md/fixtures/quote1.html",
    "2md/fixtures/quote2.html",
    "2md/fixtures/nodejs.html",
    "2md/fixtures/quote3.html",
    "2md/fixtures/nested-lists.md"
  ]) {
    let contents = (await readFile(require.resolve(path))).toString();
    const firstLine = contents.split("\n")[0];
    if (firstLine.startsWith("<!--")) {
      const match = /^<!-- From ([^ ]+?),? (.*?) by (.*?) \(([^)]+)\), (.*?) -->/.exec(
        firstLine
      );
      if (!match) {
        throw new Error(
          `couldn’t parse first-line attribution comment ${inspect(firstLine)}`
        );
      }

      const html = contents.substring(contents.indexOf("\n") + 1);

      const [sourceUrl, title, author, authorUrl, licenseName] = match.slice(1);
      fixtures.push({
        sourceUrl,
        title,
        author,
        authorUrl,
        licenseName,
        html
      });
    } else if (path.endsWith(".md")) {
      contents = (
        await remark()
          .use(html)
          .process(contents)
      ).contents.toString();
      fixtures.push({ html: contents, title: unslug(path) });
    } else {
    }
  }

  fixtures = sortBy(fixtures, f => f.title);
  const fixtureObjs = fixtures.map(f => [f.title, f]);

  const output = `\
// auto-generated by gen-fixtures.ts

export const fixtures = new Map(${JSON.stringify(fixtureObjs)});`;

  const prettierOutput = format(output, {
    parser: "babel",
    plugins: [prettierBabelPlugin]
  });

  await writeFile(targetFile, prettierOutput);
  console.log(`wrote ${targetFile}`);
}

if (require.main === module) {
  main().catch(e => {
    console.error(e);
    process.exit(1);
  });
}
