<!-- Copyright © 2020 Andrew Neitsch all rights reserved. -->

import { PauseableImage } from './pauseable-image';
import {
  DemoDom,
  DemoFlow,
  DemoHtmlEditor,
  DemoMarkdown,
  DemoIntermediate,
  DemoContent
} from "./demo-flow.tsx";

<div className="container-fluid px-0">
  <div className="jumbotron">

# Compiling HTML to Markdown with TypeScript
## How [2md][] works
[2md]: https://2md.ca

  </div>
</div>

<div className="container">

[*2020-04-04: I’d been hoping to give this as a talk at a local developer
conference today, but since that was cancelled, I’ve written this article
instead.*]

2md is a tool I built so that I could copy-and-paste from browsers into
plain-text files, while preserving a lot of the formatting by automatically
converting the HTML to markdown.

It works on mac, linux, and windows, reading HTML off the clipboard from
the command line.

<figure className="figure">
  <PauseableImage src="/doc/demo.gif" className="figure-img img-fluid rounded"/>
  <figcaption className="figure-caption">
    Copying from the browser and getting markdown in the macOS terminal.<br/>
    Click or tap to pause animation.
  </figcaption>
</figure>

Since I wrote it in TypeScript, it works in the browser too, so you can
even try it out right here on this page:

<DemoFlow>

<DemoContent/>
<div className="clearfix"/>

2md turns that markup into this markdown:

<DemoMarkdown/>
<div className="clearfix"/>

# How 2md works

In this article, I’m going to walk through how this code works in case
you’re just curious or want to be able to build something like this
yourself. At some point this would definitely have been beyond my
capabilities, and now it’s relatively straightforward for me. But there’s
no single place I know of that can help people learn how to do this. I’m
hoping to fill that gap a bit.

I’m also going to talk about why I think TypeScript is great.

And I’m going to cover some pretty gritty low-level programming details; a
lot of learning is the accumulation of low-level tricks over many years. I
love reading about those tricks in case they come in handy some day, and
enjoy sharing them too.

### Motivation

For many years I’ve kept a terminal open in one corner of the
screen where I make notes in a text editor while I work. It’s sort of like
talking to myself while I work, but it doesn’t seem weird because it’s
silent, and I end up with a searchable, timestamped record of what I was
thinking while I was working on something: what issues I was running into
when programming, the options I considered, sources I consulted, and the
resolution I ultimately arrived at.

When my work involves bits of research, I often copy and paste relevant
snippets from web sources such as [O’Reilly books][], Stack Overflow,
documentation, source code, and so on. In the moment it’s really handy to
be able to glance at the corner of the screen to see the most pertinent
documentation excerpts. Then later, I often run into an error message that
seems familiar, and am able to search upwards in my notes to find the
context around where I ran into that error message before, and the relevant
snippet that explains how to fix it.

[O’Reilly books]: https://learning.oreilly.com/

As I’ve gotten used to markdown over the years, my text notes have taken on
a markdown-ish flavour. You have to know how to use markdown to contribute
on Stack Overflow or write pull request descriptions on GitHub. And once
you know it, it becomes very convenient for general writing about
programming: it’s faster and easier to type and read and diff than raw
HTML. So I naturally started using it not only for writing things like this
article, but also in my notes. My notes aren’t all markdown because they go
back many any years and it’s still mostly me talking to myself, but I try
to use it where I can easily do so.

When pasting from the web to a `.txt` file, I found that I’d started
manually massaging what I’d pasted to make it markdown-ish.

  - Adding `>` characters at the start to clearly distinguish quotes from
    my own thoughts.
  - Wrapping the text to fit in 80 columns.
  - Separating out bullet points into little text lists.
  - Preserving *italics* where important.
  - Inserting hyperlinks.

After doing this a bunch of times, I started to think, “Surely I can
automate this.” And I was probably doing this a few times a day, just a
moment or two of rearranging a handful of lines of text in my text editor,
but getting those regular reminders saying, “I can automate this.”

Neal Ford in [The Productive Programmer][], discussing automation,
describes that when weighing whether to do a task via brute force or to
spend time and effort automating it, while automation often pays off
time-wise,

[The Productive Programmer]: https://learning.oreilly.com/library/view/the-productive-programmer/9780596519780/ch04.html#I_sect13_d1e5404

> … that’s not the important point. Performing simple, repetitive tasks
> by hand makes you dumber, and it steals part of your concentration, which
> is your most productive asset.
>
> Figuring out a clever way to automate the task makes you smarter because
> you learn something along the way.

One day I let these constant reminders get through to me, started
automating it, and am really glad I did.

### Related work

I built this for myself as a fun challenge, never pausing to consider
whether it already existed until after I’d coded it up myself from scratch.

It wasn’t until the initial version was working pretty well and I was
updating the project description on the GitHub page that I saw that were
was already an [html-to-markdown tag][] on GitHub with lots of projects,
many already written in JavaScript.

[html-to-markdown tag]: https://github.com/topics/html-to-markdown

The [turndown][] project is the big one; if you want a much more mature
html-to-markdown tool, you might want to take a look at that.

[turndown]: https://github.com/domchristie/turndown

And then many months later I was mortified to find that
[github.com/phodal/2md][] and [github.com/zshipu/2md][] had already existed
for three years, with an interactive web version at
[phodal.github.io/2md/][]! Same name and everything. Oops. When I saw that
the `2md` package name was free on [npm][], I assumed that the name `2md`
was totally original. And by the time I found out it wasn’t, I’d gotten
attached to the name for my project over many months, and wasn’t up for
changing it.

[github.com/phodal/2md]: https://github.com/phodal/2md
[github.com/zshipu/2md]: https://github.com/zshipu/2md
[phodal.github.io/2md/]: https://phodal.github.io/2md/
[npm]: https://www.npmjs.com

Also someone had asked for almost exactly what I built in a [2013 Stack
Overflow question][], so it’s definitely not an original idea.

[2013 Stack Overflow question]: https://stackoverflow.com/q/16953581/14558

## Overview

The general bodies of theory drawn from here are programming language
compilation, data structures, and graph theory. Mostly it’s about the
graphs of data structures typical of the middle stages inside a compiler.
But there’s a lot of compiler theory that’s not really relevant for this
project: we’re not implementing any lexing ourselves, and there’s no
register allocation or anything.

To help make the problem manageable, we’re going to rely on two
complementary principles:

#### <small>Principle 1:</small><br/> Instead of working with strings, work with objects

Why not go directly from HTML to markdown? You might be thinking regular
expressions would be a good start, turning `<b>…</b>` into `**…**` and so
on. And indeed a sufficiently motivated person could get surprisingly far
doing that. But things will get complicated quickly, with lots of corner
cases, and you’ll end up with too much going on at once.

An example of this sort of an approach: in some HTML, to update the CSS
class on some div, it’s definitely possible to search for the markup `<div
… class="…">` and edit the contents. You might need to create the `class`
attribute first if it doesn’t already exist, and you’ll probably want to
handle variations like `class="foo"` vs. `class='foo'` vs. `class=foo`, but
it’s doable.

Although that’s doable, the code `div.classList.toggle('expanded')` is much
shorter, easier to read and understand, faster to run, and less
error-prone.

There’s some cost of parsing the html into a data structure and turning it
back into a string at the end, but when there are many operations to
perform, or a desire to handle variations and corner cases, or when you
start to think about the problem of specifying *which* div to operate on;
the increased simplicity and precision of working with objects to perform
all those operations add up to greatly outweigh the cost of parsing the
input into some

By working at this higher level of abstraction we gain precise focus,
much more readable code, and a chance at clean APIs.

In fact DOM is a fine data structure for HTML input, and that’s what 2md
uses for its input stage. It’s the default API in browser environments
where you also get a free parser by setting `innerHTML` on elements.
`jsdom` provides command-line tools with the same DOM API as in the
browser. And whatever issues the DOM API may have for HTML, those are made
up for many times over by its ubiquity and familiarity.

#### <small>Principle 2:</small><br/> Transform the input through a sequence of data types

To turn HTML into markdown, we’re going to perform a series of
transformation steps to make it a bit more markdown-like until it
eventually *is* markdown.

<p>
<img className="center-md" src="/doc/flow.svg"/>
</p>

In this transformation sequence, sometimes the output of a step will be the
same as its input type—that’s what the loop is indicating—and sometimes
it’ll be a new output type more suited to future steps.

Though there are many benefits to using the DOM API to represent HTML, it’s
a poor fit for representing markdown. It has a bunch of stuff we don’t
need, like `classList`, and it doesn’t include a bunch of stuff that we do
care about for Markdown, like the index of an `<li>` inside an `<ol>`.

So we simplify by introducing a new data structure called an intermediate
representation: something that’s logically between two other
representations, and has similarities with both but isn’t actually either.

For 2md, the intermediate representation is called ‘Ir,’ and it’s not html
anymore, though it’s close, and it’s not quite markdown yet, though it’s
also close. I could have come up with a more descriptive name than
Ir—markml? htdown? mdish?—but there’s not confusion here yet. Sometimes the
term ‘intermediate representation’ gets very confusing if you end up with a
bunch of different intermediate representations inside a compiler, with all
of those different representations having very similar names.

How many different representations do you need? Well, it depends.
I started out with two, DOM and Ir, and
later added a third called OutputBlocks.

### Details

for some raw html

## Editable HTML

Here’s that selector again:

<DemoContent/>
<div className="clearfix"/>

now the raw HTML we get for that is pretty messy

these examples all come from copying and pasting from Safari on a mac,
which means all the styles get inlined

<DemoHtmlEditor/>

## DOM:

we get a DOM tree

<DemoDom/>

    function parse1(irNode: IrNode, htmlNode: Node) {
      if (
        htmlNode.nodeType == htmlNode.TEXT_NODE &&
        htmlNode.textContent !== null
      ) {
        if (
          htmlNode.textContent !== "\n" ||
          irNode.isOrHasParentNamed("Preformatted")
        ) {
          irNode.push(htmlNode.textContent);
        }
      } else if (htmlNode.nodeType == htmlNode.ELEMENT_NODE) {
        const e = <Element>htmlNode;
        let receiver = irNode;
        switch (htmlNode.nodeName) {
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
            receiver = new Heading([], {
              level: extractHeadingLevel(htmlNode.nodeName)
            });
            break;
          case "B":
          case "STRONG":
            receiver = new Bold([]);
            break;
          case "I":
          case "EM":
            receiver = new I([]);
            break;
          case "OL":
            receiver = new OrderedList([]);
            break;
          case "LI":
            receiver = new ListItem([]);
            break;
          case "A":
            const href = e.getAttribute("href");
            if (href) {
              receiver = new A([], { href });
            }
            break;
          case "PRE":
            receiver = new Preformatted([]);
            break;
          case "P":
          // There’s no standard markdown representation for these, but putting them
          // on separate lines is better than jamming them together in a single
          // paragraph.
          case "DL":
          case "DT":
            receiver = new P([]);
            break;
          case "BLOCKQUOTE":
            receiver = new Blockquote([]);
            break;
          case "TT":
          case "CODE":
            receiver = new Code([]);
            break;
          case "BR":
            receiver = new Br([]);
            break;
        }
        if (irNode !== receiver) irNode.push(receiver);

        for (let i = 0; i < htmlNode.childNodes.length; i++) {
          const c = htmlNode.childNodes[i];
          parse1(receiver, c);
        }
      }
    }

## Intermediate:

and map that to IR

<DemoIntermediate/>
<div className="clearfix"/>

## Markdown

<DemoMarkdown/>
<div className="clearfix"/>

</DemoFlow>








</div>
