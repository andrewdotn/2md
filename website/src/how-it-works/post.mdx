<!-- Copyright © 2020 Andrew Neitsch all rights reserved. -->

import { PauseableImage } from './pauseable-image';
import {
  DemoCharCount,
  DemoContent,
  DemoDom,
  DemoFlow,
  DemoHtmlEditor,
  DemoIntermediate,
  DemoMarkdown,
  DemoOutputBlocks,
  DemoUntransformedIntermediate,
} from "./demo-flow.tsx";

<div className="container-fluid px-0">
  <div className="jumbotron">

# Compiling HTML to Markdown with TypeScript
## How [2md][] works
[2md]: https://2md.ca

  </div>
</div>

<div className="container">

[*2020-04-04: I’d been hoping to give this as a talk at a local developer
conference today, but since that was cancelled, I’ve written this article
instead.*]

2md is a tool I built so that I could copy-and-paste from browsers into
plain-text files, while preserving a lot of the formatting by automatically
converting the HTML to markdown.

It works on mac, linux, and windows, reading HTML off the clipboard from
the command line. You can see source code and install instructions [on
GitHub][2md-github].

[2md-github]: https://github.com/andrewdotn/2md

<figure className="figure">
  <PauseableImage src="/doc/demo.gif" className="figure-img img-fluid rounded"/>
  <figcaption className="figure-caption">
    Copying from the browser and getting markdown in the macOS terminal.<br/>
    Click or tap to pause animation.
  </figcaption>
</figure>

Since I wrote it in TypeScript, it works in the browser too, so you can
even try it out right here on this page.

<DemoFlow>

<DemoContent/>
<div className="clearfix"/>

2md turns the markup for that into this markdown:

<DemoMarkdown/>
<div className="clearfix"/>

# How 2md works

In this article, I’m going to walk through how this code works in case
you’re just curious or want to be able to build something like this
yourself. At some point this would definitely have been beyond my
capabilities, and now it’s relatively straightforward for me. But there’s
no single place I know of that can help people learn how to do this. I’m
hoping to fill that gap a bit.

I’m also going to talk about why I think TypeScript is great.

And I’m going to cover some pretty gritty low-level programming details; a
lot of learning is the accumulation of low-level tricks over many years. I
love reading about those tricks in case they come in handy some day, and
enjoy sharing them too.

### Motivation

For many years I’ve kept a terminal open in one corner of the
screen where I make notes in a text editor while I work. It’s sort of like
talking to myself while I work, but it doesn’t seem weird because it’s
silent, and I end up with a searchable, timestamped record of what I was
thinking while I was working on something: what issues I was running into
when programming, the options I considered, sources I consulted, and the
resolution I ultimately arrived at.

When my work involves bits of research, I often copy and paste relevant
snippets from web sources such as [O’Reilly books][], Stack Overflow,
documentation, source code, and so on. In the moment it’s really handy to
be able to glance at the corner of the screen to see the most pertinent
documentation excerpts. Then later, I often run into an error message that
seems familiar, and am able to search upwards in my notes to find the
context around where I ran into that error message before, and the relevant
snippet that explains how to fix it.

[O’Reilly books]: https://learning.oreilly.com/

As I’ve gotten used to markdown over the years, my text notes have taken on
a markdown-ish flavour. You have to know how to use markdown to contribute
on Stack Overflow or write pull request descriptions on GitHub. And once
you know it, it becomes very convenient for general writing about
programming: it’s faster and easier to type and read and diff than raw
HTML. So I naturally started using it not only for writing things like this
article, but also in my notes. My notes aren’t all markdown because they go
back many any years and it’s still mostly me talking to myself, but I try
to use it where I can easily do so.

When pasting from the web to a `.txt` file, I found that I’d started
manually massaging what I’d pasted to make it markdown-ish.

  - Adding `>` characters at the start to clearly distinguish quotes from
    my own thoughts.
  - Wrapping the text to fit in 80 columns.
  - Separating out bullet points into little text lists.
  - Preserving *italics* where important.
  - Inserting hyperlinks.

After doing this a bunch of times, I started to think, “Surely I can
automate this.” And I was probably doing this a few times a day, just a
moment or two of rearranging a handful of lines of text in my text editor,
but getting those regular reminders saying, “I can automate this.”

Neal Ford in [The Productive Programmer][], discussing automation,
describes that when weighing whether to do a task via brute force or to
spend time and effort automating it, while automation often pays off
time-wise,

[The Productive Programmer]: https://learning.oreilly.com/library/view/the-productive-programmer/9780596519780/ch04.html#I_sect13_d1e5404

> … that’s not the important point. Performing simple, repetitive tasks
> by hand makes you dumber, and it steals part of your concentration, which
> is your most productive asset.
>
> Figuring out a clever way to automate the task makes you smarter because
> you learn something along the way.

One day I let these constant reminders get through to me, started
automating it, and am really glad I did.

### Related work

I built this for myself as a fun challenge, never pausing to consider
whether it already existed until after I’d coded it up myself from scratch.

It wasn’t until the initial version was working pretty well and I was
updating the project description on the GitHub page that I saw that were
was already an [html-to-markdown tag][] on GitHub with lots of projects,
many already written in JavaScript.

[html-to-markdown tag]: https://github.com/topics/html-to-markdown

The [turndown][] project is the big one; if you want a much more mature
html-to-markdown tool, you might want to take a look at that.

[turndown]: https://github.com/domchristie/turndown

And then many months later I was mortified to find that
[github.com/phodal/2md][] and [github.com/zshipu/2md][] had already existed
for three years, with an interactive web version at
[phodal.github.io/2md/][]! Same name and everything. Oops. When I saw that
the `2md` package name was free on [npm][], I assumed that the name `2md`
was totally original. And by the time I found out it wasn’t, I’d gotten
attached to the name for my project over many months, and wasn’t up for
changing it.

[github.com/phodal/2md]: https://github.com/phodal/2md
[github.com/zshipu/2md]: https://github.com/zshipu/2md
[phodal.github.io/2md/]: https://phodal.github.io/2md/
[npm]: https://www.npmjs.com

Also someone had asked for almost exactly what I built in a [2013 Stack
Overflow question][], so it’s definitely not an original idea.

[2013 Stack Overflow question]: https://stackoverflow.com/q/16953581/14558

## Overview

The general bodies of theory drawn from here are programming language
compilation, data structures, and graph theory. Mostly it’s about the
graphs of data structures typical of the middle stages inside a compiler.
But there’s a lot of compiler theory that’s not really relevant for this
project: we’re not implementing any lexing ourselves, and there’s no
register allocation or anything.

To help make the problem manageable, we’re going to rely on two
complementary principles:

#### <small>Principle 1:</small><br/> Instead of working with strings, work with objects

Why not go directly from HTML to markdown? You might be thinking regular
expressions would be a good start, turning `<b>…</b>` into `**…**` and so
on. And indeed a sufficiently motivated person could get surprisingly far
doing that. But things will get complicated quickly, with lots of corner
cases, and you’ll end up with too much going on at once.

An example of this sort of an approach: in some HTML, to update the CSS
class on some div, it’s definitely possible to search for the markup `<div
… class="…">` and edit the contents. You might need to create the `class`
attribute first if it doesn’t already exist, and you’ll probably want to
handle variations like `class="foo"` vs. `class='foo'` vs. `class=foo`, but
it’s doable.

Although that’s doable, the code `div.classList.toggle('expanded')` is much
shorter, easier to read and understand, faster to run, and less
error-prone.

There’s some cost of parsing the HTML into a data structure and turning it
back into a string at the end, but when there are many operations to
perform, or a desire to handle variations and corner cases, or when you
start to think about the problem of specifying *which* div to operate on;
the increased simplicity and precision of working with objects to perform
all those operations add up to greatly outweigh the cost of parsing the
input into some

By working at this higher level of abstraction we gain precise focus,
much more readable code, and a chance at clean APIs.

In fact the Document Object Model standard aka DOM is a fine data structure
for HTML input, and that’s what 2md uses for its input stage. It’s the
default API in browser environments where you also get a free parser by
setting `innerHTML` on elements. `jsdom` provides command-line tools with
the same DOM API as in the browser. And whatever issues the DOM API may
have for HTML, those are made up for many times over by its ubiquity and
familiarity.

#### <small>Principle 2:</small><br/> Transform the input through a sequence of data types

To turn HTML into markdown, we’re going to perform a series of
transformation steps to make it a bit more markdown-like until it
eventually *is* markdown.

<p>
<img className="center-md" src="/doc/flow.svg"/>
</p>

In this transformation sequence, sometimes the output of a step will be the
same as its input type—that’s what the loop is indicating—and sometimes
it’ll be a new output type more suited to future steps.

Though there are many benefits to using the DOM API to represent HTML, it’s
a poor fit for representing markdown. It has a bunch of stuff we don’t
need, like `classList`, and it doesn’t include a bunch of stuff that we do
care about for markdown, like the index of an `<li>` inside an `<ol>`.

So we simplify by introducing a new data structure called an intermediate
representation: something that’s logically between two other
representations, and has similarities with both but isn’t actually either.

For 2md, the intermediate representation is called `Ir`, and it’s not HTML
anymore, though it’s close, and it’s not quite markdown yet, though it’s
also close. I could have come up with a more descriptive name than
Ir—markml? htdown? mdish?—but calling it an IR, or IL for ‘intermediate
language,’ is traditional. Sometimes the term ‘intermediate representation’
gets very confusing if you end up with a bunch of different intermediate
representations inside a compiler, with all of those different
representations having very similar names. For 2md, there is another
intermediate representation called OutputBlocks, but the names are
different enough to avoid confusion.

How many different intermediate representations do you need? Well, it
depends. I started out with two, DOM and Ir, and later added a third called
OutputBlocks when that seemed prudent. It’s something you learn about the
problem space as you write code that works in it. If the current
representation is getting too complicated, or you’re adding a bunch of
specialized functionality, it makes sense to introduce a new
representation. And sometimes you end up with too many intermediate steps
that are too similar that just waste a lot of time passing the same data
around, and waste your time when you’re trying to find the part where
things actually happen, and you edit the code to reduce the number of
intermediate representations.

It’s a lot like object-oriented programming, where you often start out with
one class, and then that one class starts doing too many different things,
split it up into different more-focused classes. Except here instead of a
single class, each representation is composed of a whole family of classes.

## Details

All right, finally it’s time to look at some source code excerpts, and some
real live data structures!

Here’s that selector/paste box again:

<DemoContent/>

### Raw HTML

The raw HTML for these snippets is generally pretty messy:

<DemoHtmlEditor/>

These examples mostly come from copying and pasting from Safari on a mac.
Other browsers seem to be similar, but the important thing is that to make
note of is that, in order to make the snippet self-contained, the browser
took all the computed styles from all the CSS and inlined it on every
element, making the markup really messy. And glomming everything onto one
line makes it a lot harder to read.

Instead of staring at a <DemoCharCount/>-character string, let’s pop it
into a DOM tree to collapse the `style="…"` nodes and reveal the tree
structure.

### DOM tree

Parsing HTML into DOM objects is a very important part of the browser’s
reason for existence, and it’ll just do that naturally if formatted text is
pasted into a `contentEditable` area, at which point your object reference
to the `contentEditable` is your handle into the DOM tree.

To get DOM objects from HTML *strings* inside a browser, you can create a
new document and then set the body HTML:

    const doc = document.implementation.createHTMLDocument();
    doc.body.innerHTML = 'Hello, <b>world</b>';
    doc.documentElement.outerHTML;
    // returns "<html><head></head><body>Hello, <b>world</b></body></html>"

In node.js, the `jsdom` package provides a string-taking constructor
directly, and returns objects with the same API that you’d get in the
browser:

    const { JSDOM } = require('jsdom');
    const doc = new JSDOM('Hello, <b>world</b>').window.document;
    doc.documentElement.outerHTML;
    // returns "<html><head></head><body>Hello, <b>world</b></body></html>"

At this point, you’ve got DOM `Node` objects with familiar APIs like
`node.childNodes`, `node.appendChild()`, `node.replaceChild()`,
`node.nodeType` which has to be compared against various integer constants;
essentially all the stuff that jQuery does behind the scenes.

<DemoDom/>

### Building the intermediate representation

How to start turning that DOM tree into markdown?

Well, there’s lots that can be thrown away, like any HTML comments, the contents
of any `class=""` attributes; and we don’t care about `<div>`s or `<span>`s; …
in fact we’re going to throw away everything except for text and a small number
of tags, and do some normalization such as mapping both `<i>foo</i>` and
`<em>foo</em>` into the same thing because they’ll both come out the markdown
end as `*foo*`.

And this is where Ir comes into play: it’s a simplified, normalized data
structure to make the HTML input more markdown-like.

Each Ir node has:

  - A name, and possibly an attribute, from the following list, roughly
    corresponding to the subset of HTML that’s relevant to generating
    markdown:
      - A (attribute: href)
      - Blockquote
      - Bold
      - Br
      - Code
      - Heading (attribute: level)
      - I
      - ListItem
      - NumberedListItem (attribute: number)
      - OrderedList
      - P
      - Preformatted
      - Document
  - A list of children, all of which are either other Ir nodes or plain
    strings.

The code to actually do this is in `src/parse.ts`:

  - If the current DOM node is text, add it to the current Ir node’s
    children
  - If the current DOM node is an ‘interesting’ HTML tag, create a new Ir node
    for it, and add it as a child of the current Ir node
  - Then recurse down into any child nodes of the current DOM node

The code:

    function parse(doc: Node): IrNode {
      const root = new Document([]);

      for (let i = 0; i < doc.childNodes.length; i++) {
        parse1(root, doc.childNodes[i]);
      }
    }

    // This is the actual recursive function; I think I picked up the naming
    // convention from Lisp. When a recursive function needs accumulators, `foo()`
    // is the simplified API used by callers that does the initial setup, and
    // `foo1()` recurses.
    function parse1(irNode: IrNode, htmlNode: Node) {
      if (
        htmlNode.nodeType == htmlNode.TEXT_NODE &&
        htmlNode.textContent !== null
      ) {
        if (
          htmlNode.textContent !== "\n" ||
          irNode.isOrHasParentNamed("Preformatted")
        ) {
          irNode.push(htmlNode.textContent);
        }
      } else if (htmlNode.nodeType == htmlNode.ELEMENT_NODE) {
        const e = <Element>htmlNode;
        let receiver = irNode;
        switch (htmlNode.nodeName) {
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
            receiver = new Heading([], {
              level: extractHeadingLevel(htmlNode.nodeName)
            });
            break;
          case "B":
          case "STRONG":
            receiver = new Bold([]);
            break;
          case "I":
          case "EM":
            receiver = new I([]);
            break;
          case "OL":
            receiver = new OrderedList([]);
            break;
          case "LI":
            receiver = new ListItem([]);
            break;
          case "A":
            const href = e.getAttribute("href");
            if (href) {
              receiver = new A([], { href });
            }
            break;
          case "PRE":
            receiver = new Preformatted([]);
            break;
          case "P":
          // There’s no standard markdown representation for these, but putting them
          // on separate lines is better than jamming them together in a single
          // paragraph.
          case "DL":
          case "DT":
            receiver = new P([]);
            break;
          case "BLOCKQUOTE":
            receiver = new Blockquote([]);
            break;
          case "TT":
          case "CODE":
            receiver = new Code([]);
            break;
          case "BR":
            receiver = new Br([]);
            break;
        }
        if (irNode !== receiver) irNode.push(receiver);

        // Recurse
        for (let i = 0; i < htmlNode.childNodes.length; i++) {
          const c = htmlNode.childNodes[i];
          parse1(receiver, c);
        }
      }
    }

The result is a tree, a lot like the DOM tree, but with only about a dozen
possible node types, only three of which can have any attributes.

<DemoUntransformedIntermediate/>

### Tree transforms

Now that we’re getting closer to markdown, we can perform some operations
directly on the Ir tree, without moving to a new representation.

Here are some examples of tree transform functions from
`src/tree-transforms.ts`.

  - Turn things that started out as `<pre><code>…</code></pre>` into plain
    Preformatted Ir nodes, without an inner Code node.

    Markdown has two different kinds of code blocks: *inline
    code*, <code>&#96;foo&#96;</code>, normally rendered as <code>&lt;code
    …/&gt;</code>, and *code blocks*, typically designated with a
    four-space-indent inside markdown source

        function foo () {
            ...
        }

    that gets rendered into HTML as `<pre><code>…</code></pre>`.

    When going from HTML to markdown, `<code>` should turn
    into <code>&#96;foo&#96;</code>, and 2md has a Code class to represent
    inline code. Meanwhile HTML of the form `<pre><code>…</code></pre>`
    should turn into a Preformatted Ir node, with no Code object,
    to represent a code *block*.

    The initial Ir tree comes from a fairly direct mapping of HTML tags, so
    also ends up with a Code node as a child of a Preformatted node.
    There’s no need for that, and we don’t want to emit four-space-indented
    blocks with an extra <code>&DiacriticalGrave;</code> in there,
    so that should be simplified.

    The code to do that is

        function collapseCodeInsidePre(node: IrNode) {
          if (node.name !== "Preformatted") {
            return;
          }

          if (node.childCount() === 1) {
            const c = node.child(0);
            if (typeof c !== "string" && c.name === "Code") {
              node.replaceChildWithItsChildren();
            }
          }
        }

    which is called from a wrapper function that handles the traversal
    boilerplate.

  - For `<ul><li>…` markup we can emit `"  - "` markdown without regard for the
    context surround where the `<li>` occurs.

    But for an `<li>` inside an `<ol>`, we need to emit a number
    corresponding to the index in the parent list.

    So there’s a `numberLists` transform which walks along, counting, and
    sets the correct `index` attribute on every NumberedListItem.

  - Concatenate adjacent string children into a single string, purely to
    make it easier to understand what is going on. This is especially
    noticeable for the syntax highlighting in the ‘Node JS’ and ‘Stack
    Overflow’ examples, where each `<span … />` for colour ends up being a
    separate string without this optimization.

        /**
         * If two subsequent nodes are strings, concatenate them. This optimization pass
         * should be quick, and is here entirely to make unit test input cleaner.
         */
        function concatenateStrings(node: IrNode) {
          for (let i = 0; i < node.childCount() - 1; i++) {
            const c0 = node.child(i);
            const c1 = node.child(i + 1);
            if (typeof c0 === "string" && typeof c1 === "string") {
              node.setChild(i, c0 + c1);
              node.removeChild(i + 1);
              // Since we just deleted the element at the current index, decrement
              // the loop index, otherwise we’ll miss the next element which has
              // shifted down into the current position.
              i--;
            }
          }
        }

With all that and more, the output is the same Ir tree as before, now a bit
more markdown-ish.

<DemoIntermediate/>

We’re almost ready for output!

### OutputBlocks

There’s actually another important thing about Ir objects that I didn’t
mention earlier: a `render()` method. This is how the Ir tree gets turned
into a markdown string.

All the Ir classes are defined in `src/2md.ts`,
and here’s one of them:

    export class Code extends IrNode {
      static irName: NodeName = "Code";

      render(r: BlockRendering) {
        r.append("`");
        super.render(r);
        r.append("`");
      }
    }

Pretty easy! To output an inline code block: output a <code>&#96;</code>
character, call the superclass `render()` method to render any children of
this node, and then output another <code>&#96;</code> character.

What about a block?

    export class ListItem extends IrNode {
      static irName: NodeName = "ListItem";

      render(r: BlockRendering) {
        const prefix = new Prefix("  - ", "    ");
        r.pushPrefix(prefix);
        super.render(r);
        r.popPrefix(prefix);
      }
    }

Pretty straightforward: the prefix says to use `"  - "` for the first line
of a bullet list, and `"    "` for subsequent lines.

The interface for `BlockRendering` is pretty small:

    export declare class BlockRendering {
      append(s: string, newline?: boolean): void;
      pushPrefix(prefix: Prefix, wrapOptions?: BlockOptions): void;
      popPrefix(prefix: Prefix): void;
      /** Used for collecting link info to add on at the end */
      addTrailer(s: string): void;

      finish(): string;
    }

At this point, why can’t we directly write out the contents as a string?

Nesting. If you have, for example, a code block in a bulleted list
inside a blockquote, the start of the line is

    >   -     foo

which shows up as

>   -     foo

but if that same code block starts on a later line of the bullet point,
there’s no `-`:

    >   - Here is some code:
    >
    >         foo
    >
    > …

and ithat shows up as:

>   - Here is some code:
>
>         foo
>
> …

The render function inside the Code class doesn’t and shouldn’t know
whether it’s at the start of a bullet point or not.

<DemoOutputBlocks/>

### Markdown

And finally we have markdown!

<DemoMarkdown/>


</DemoFlow>








</div>
