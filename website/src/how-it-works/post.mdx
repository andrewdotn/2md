<!-- Copyright © 2020 Andrew Neitsch all rights reserved. -->

import { PauseableImage } from './pauseable-image';
import {
  DemoCharCount,
  DemoContent,
  DemoDom,
  DemoFlow,
  DemoHtmlEditor,
  DemoIntermediate,
  DemoMarkdown,
  DemoOutputBlocks,
  DemoUntransformedIntermediate,
} from "./demo-flow.tsx";

<div className="container-fluid px-0">
  <div className="jumbotron">

# Compiling HTML to Markdown with TypeScript
## How [2md][] works
[2md]: https://2md.ca

  </div>
</div>

<div className="container">

[*2020-04-04: I’d been hoping to give this as a talk at a local developer
conference today, but since that was cancelled, I’ve written this article
instead.*]

2md is a tool I built so that I could copy-and-paste from browsers into
plain-text files, while preserving a lot of the formatting by automatically
converting the HTML to markdown.

It works on mac, linux, and windows, reading HTML off the clipboard from
the command line. You can see source code and install instructions [on
GitHub][2md-github].

[2md-github]: https://github.com/andrewdotn/2md

<figure className="figure">
  <PauseableImage src="/doc/demo.gif" className="figure-img img-fluid rounded"/>
  <figcaption className="figure-caption">
    Copying from the browser and getting markdown in the macOS terminal.<br/>
    Click or tap to pause animation.
  </figcaption>
</figure>

Since I wrote it in TypeScript, it works in the browser too, so you can
even try it out right here on this page.

<DemoFlow>

<DemoContent/>
<div className="clearfix"/>

2md turns the markup for that into this markdown:

<DemoMarkdown/>
<div className="clearfix"/>

# How 2md works

In this article, I’m going to walk through how this code works in case
you’re just curious or want to be able to build something like this
yourself. At some point this would definitely have been beyond my
capabilities, and now it’s relatively straightforward for me. But there’s
no single place I know of that can help people learn how to do this. I’m
hoping to fill that gap a bit.

I’m also going to talk about why I think TypeScript is great.

And I’m going to cover some pretty gritty low-level programming details; a
lot of learning is the accumulation of low-level tricks over many years. I
love reading about those tricks in case they come in handy some day, and
enjoy sharing them too.

<!-- wrapper is used to target styling for toc headings -->
<div className="toc">

### Table of Contents

<!--
  -- the div end has to come after the next header because remark-toc
  -- replaces everything in this section with the table of contents
  -->

## Motivation
</div>

For many years I’ve kept a terminal open in one corner of the
screen where I make notes in a text editor while I work. It’s sort of like
talking to myself while I work, but it doesn’t seem weird because it’s
silent, and I end up with a searchable, timestamped record of what I was
thinking while I was working on something: what issues I was running into
when programming, the options I considered, sources I consulted, and the
resolution I ultimately arrived at.

When my work involves bits of research, I often copy and paste relevant
snippets from web sources such as [O’Reilly books][], Stack Overflow,
documentation, source code, and so on. In the moment it’s really handy to
be able to glance at the corner of the screen to see the most pertinent
documentation excerpts. Then later, I often run into an error message that
seems familiar, and am able to search upwards in my notes to find the
context around where I ran into that error message before, and the relevant
snippet that explains how to fix it.

[O’Reilly books]: https://learning.oreilly.com/

As I’ve gotten used to markdown over the years, my text notes have taken on
a markdown-ish flavour. You have to know how to use markdown to contribute
on Stack Overflow or write pull request descriptions on GitHub. And once
you know it, it becomes very convenient for general writing about
programming: it’s faster and easier to type and read and diff than raw
HTML. So I naturally started using it not only for writing things like this
article, but also in my notes. My notes aren’t all markdown because they go
back many any years and it’s still mostly me talking to myself, but I try
to use it where I can easily do so.

When pasting from the web to a `.txt` file, I found that I’d started
manually massaging what I’d pasted to make it markdown-ish.

  - Adding `>` characters at the start to clearly distinguish quotes from
    my own thoughts.
  - Wrapping the text to fit in 80 columns.
  - Separating out bullet points into little text lists.
  - Preserving *italics* where important.
  - Inserting hyperlinks.

After doing this a bunch of times, I started to think, “Surely I can
automate this.” And I was probably doing this a few times a day, just a
moment or two of rearranging a handful of lines of text in my text editor,
but getting those regular reminders saying, “I can automate this.”

Neal Ford in [The Productive Programmer][], discussing automation,
describes that when weighing whether to do a task via brute force or to
spend time and effort automating it, while automation often pays off
time-wise,

[The Productive Programmer]: https://learning.oreilly.com/library/view/the-productive-programmer/9780596519780/ch04.html#I_sect13_d1e5404

> … that’s not the important point. Performing simple, repetitive tasks
> by hand makes you dumber, and it steals part of your concentration, which
> is your most productive asset.
>
> Figuring out a clever way to automate the task makes you smarter because
> you learn something along the way.

One day I let these constant reminders get through to me, started
automating it, and am really glad I did.

### Related work

I built this for myself as a fun challenge, never pausing to consider
whether it already existed until after I’d coded it up myself from scratch.

It wasn’t until the initial version was working pretty well and I was
updating the project description on the GitHub page that I saw that were
was already an [html-to-markdown tag][] on GitHub with lots of projects,
many already written in JavaScript.

[html-to-markdown tag]: https://github.com/topics/html-to-markdown

The [turndown][] project is the big one; if you want a much more mature
html-to-markdown tool, you might want to take a look at that.

[turndown]: https://github.com/domchristie/turndown

And then many months later I was mortified to find that
[github.com/phodal/2md][] and [github.com/zshipu/2md][] had already existed
for three years, with an interactive web version at
[phodal.github.io/2md/][]! Same name and everything. Oops. When I saw that
the `2md` package name was free on [npm][], I assumed that the name `2md`
was totally original. And by the time I found out it wasn’t, I’d gotten
attached to the name for my project over many months, and wasn’t up for
changing it.

[github.com/phodal/2md]: https://github.com/phodal/2md
[github.com/zshipu/2md]: https://github.com/zshipu/2md
[phodal.github.io/2md/]: https://phodal.github.io/2md/
[npm]: https://www.npmjs.com

Also someone had asked for almost exactly what I built in a [2013 Stack
Overflow question][], so it’s definitely not an original idea.

[2013 Stack Overflow question]: https://stackoverflow.com/q/16953581/14558

## Overview

The general bodies of theory drawn from here are programming language
compilation, data structures, and graph theory. Mostly it’s about the
graphs of data structures typical of the middle stages inside a compiler.
But there’s a lot of compiler theory that’s not really relevant for this
project: we’re not implementing any lexing ourselves, and there’s no
register allocation or anything.

To help make the problem manageable, we’re going to rely on two
complementary principles:

#### <small>Principle 1:</small><br/> Instead of working with strings, work with objects

Why not go directly from HTML to markdown? You might be thinking regular
expressions would be a good start, turning `<b>…</b>` into `**…**` and so
on. And indeed a sufficiently motivated person could get surprisingly far
doing that. But things will get complicated quickly, with lots of corner
cases, and you’ll end up with too much going on at once.

An example of this sort of an approach: in some HTML, to update the CSS
class on some div, it’s definitely possible to search for the markup `<div
… class="…">` and edit the contents. You might need to create the `class`
attribute first if it doesn’t already exist, and you’ll probably want to
handle variations like `class="foo"` vs. `class='foo'` vs. `class=foo`, but
it’s doable.

Although that’s doable, the code `div.classList.toggle('expanded')` is much
shorter, easier to read and understand, faster to run, and less
error-prone.

There’s some cost of parsing the HTML into a data structure and turning it
back into a string at the end, but when there are many operations to
perform, or a desire to handle variations and corner cases, or when you
start to think about the problem of specifying *which* div to operate on;
the increased simplicity and precision of working with objects to perform
all those operations add up to greatly outweigh the cost of parsing the
input into some

By working at this higher level of abstraction we gain precise focus,
much more readable code, and a chance at clean APIs.

In fact the Document Object Model standard aka DOM is a fine data structure
for HTML input, and that’s what 2md uses for its input stage. It’s the
default API in browser environments where you also get a free parser by
setting `innerHTML` on elements. `jsdom` provides command-line tools with
the same DOM API as in the browser. And whatever issues the DOM API may
have for HTML, those are made up for many times over by its ubiquity and
familiarity.

#### <small>Principle 2:</small><br/> Transform the input through a sequence of data types

To turn HTML into markdown, we’re going to perform a series of
transformation steps to make it a bit more markdown-like until it
eventually *is* markdown.

<p>
<img className="center-md" src="/doc/flow.svg"/>
</p>

In this transformation sequence, sometimes the output of a step will be the
same as its input type—that’s what the loop is indicating—and sometimes
it’ll be a new output type more suited to future steps.

Though there are many benefits to using the DOM API to represent HTML, it’s
a poor fit for representing markdown. It has a bunch of stuff we don’t
need, like `classList`, and it doesn’t include a bunch of stuff that we do
care about for markdown, like the index of an `<li>` inside an `<ol>`.

So we simplify by introducing a new data structure called an intermediate
representation: something that’s logically between two other
representations, and has similarities with both but isn’t actually either.

For 2md, the intermediate representation is called `Ir`, and it’s not HTML
anymore, though it’s close, and it’s not quite markdown yet, though it’s
also close. I could have come up with a more descriptive name than
Ir—markml? htdown? mdish?—but calling it an IR, or IL for ‘intermediate
language,’ is traditional. Sometimes the term ‘intermediate representation’
gets very confusing if you end up with a bunch of different intermediate
representations inside a compiler, with all of those different
representations having very similar names. For 2md, there is another
intermediate representation called OutputBlocks, but the names are
different enough to avoid confusion.

How many different intermediate representations do you need? Well, it
depends. I started out with two, DOM and Ir, and later added a third called
OutputBlocks when that seemed prudent. It’s something you learn about the
problem space as you write code that works in it. If the current
representation is getting too complicated, or you’re adding a bunch of
specialized functionality, it makes sense to introduce a new
representation. And sometimes you end up with too many intermediate steps
that are too similar that just waste a lot of time passing the same data
around, and waste your time when you’re trying to find the part where
things actually happen, and you edit the code to reduce the number of
intermediate representations.

It’s a lot like object-oriented programming, where you often start out with
one class, and then that one class starts doing too many different things,
split it up into different more-focused classes. Except here instead of a
single class, each representation is composed of a whole family of classes.

Incidentally, even if you weren’t working in a vacuum and reused an
existing library like `mdast` to represent the markdown output, I expect
that the code would be easier to write and maintain with an intermediate
representation expect between the DOM and markdown representations.

## Details

All right, finally it’s time to look at some source code excerpts, and some
real live data structures!

Here’s that selector/paste box again:

<DemoContent/>

### Raw HTML

The raw HTML for these snippets is generally pretty messy:

<DemoHtmlEditor/>

These examples mostly come from copying and pasting from Safari on a mac.
Other browsers seem to be similar, but the important thing is that to make
note of is that, in order to make the snippet self-contained, the browser
took all the computed styles from all the CSS and inlined it on every
element, making the markup really messy. And glomming everything onto one
line makes it a lot harder to read.

Instead of staring at a <DemoCharCount/>-character string, let’s pop it
into a DOM tree to collapse the `style="…"` nodes and reveal the tree
structure.

### DOM tree

Parsing HTML into DOM objects is a very important part of the browser’s
reason for existence, and it’ll just do that naturally if formatted text is
pasted into a `contentEditable` area, at which point your object reference
to the `contentEditable` is your handle into the DOM tree.

To get DOM objects from HTML *strings* inside a browser, you can create a
new document and then set the body HTML:

    const doc = document.implementation.createHTMLDocument();
    doc.body.innerHTML = 'Hello, <b>world</b>';
    doc.documentElement.outerHTML;
    // returns "<html><head></head><body>Hello, <b>world</b></body></html>"

In node.js, the `jsdom` package provides a string-taking constructor
directly, and returns objects with the same API that you’d get in the
browser:

    const { JSDOM } = require('jsdom');
    const doc = new JSDOM('Hello, <b>world</b>').window.document;
    doc.documentElement.outerHTML;
    // returns "<html><head></head><body>Hello, <b>world</b></body></html>"

At this point, you’ve got DOM `Node` objects with familiar APIs like
`node.childNodes`, `node.appendChild()`, `node.replaceChild()`,
`node.nodeType` which has to be compared against various integer constants;
essentially all the stuff that jQuery does behind the scenes.

<DemoDom/>

### Building the intermediate representation

How to start turning that DOM tree into markdown?

Well, there’s lots that can be thrown away, like any HTML comments, the contents
of any `class=""` attributes; and we don’t care about `<div>`s or `<span>`s; …
in fact we’re going to throw away everything except for text and a small number
of tags, and do some normalization such as mapping both `<i>foo</i>` and
`<em>foo</em>` into the same thing because they’ll both come out the markdown
end as `*foo*`.

And this is where Ir comes into play: it’s a simplified, normalized data
structure to make the HTML input more markdown-like.

Each Ir node has:

  - A name, and possibly an attribute, from the following list, roughly
    corresponding to the subset of HTML that’s relevant to generating
    markdown:
      - A (attribute: href)
      - Blockquote
      - Bold
      - Br
      - Code
      - Heading (attribute: level)
      - I
      - ListItem
      - NumberedListItem (attribute: number)
      - OrderedList
      - P
      - Preformatted
      - Document
  - A list of children, all of which are either other Ir nodes or plain
    strings.

The code to actually do this is in `src/parse.ts`:

  - If the current DOM node is text, add it to the current Ir node’s
    children
  - If the current DOM node is an ‘interesting’ HTML tag, create a new Ir node
    for it, and add it as a child of the current Ir node
  - Then recurse down into any child nodes of the current DOM node

The code:

    function parse(doc: Node): IrNode {
      const root = new Document([]);

      for (let i = 0; i < doc.childNodes.length; i++) {
        parse1(root, doc.childNodes[i]);
      }
    }

    // This is the actual recursive function; I think I picked up the naming
    // convention from Lisp. When a recursive function needs accumulators, `foo()`
    // is the simplified API used by callers that does the initial setup, and
    // `foo1()` recurses.
    function parse1(irNode: IrNode, htmlNode: Node) {
      if (
        htmlNode.nodeType == htmlNode.TEXT_NODE &&
        htmlNode.textContent !== null
      ) {
        if (
          htmlNode.textContent !== "\n" ||
          irNode.isOrHasParentNamed("Preformatted")
        ) {
          irNode.push(htmlNode.textContent);
        }
      } else if (htmlNode.nodeType == htmlNode.ELEMENT_NODE) {
        const e = <Element>htmlNode;
        let receiver = irNode;
        switch (htmlNode.nodeName) {
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
            receiver = new Heading([], {
              level: extractHeadingLevel(htmlNode.nodeName)
            });
            break;
          case "B":
          case "STRONG":
            receiver = new Bold([]);
            break;
          case "I":
          case "EM":
            receiver = new I([]);
            break;
          case "OL":
            receiver = new OrderedList([]);
            break;
          case "LI":
            receiver = new ListItem([]);
            break;
          case "A":
            const href = e.getAttribute("href");
            if (href) {
              receiver = new A([], { href });
            }
            break;
          case "PRE":
            receiver = new Preformatted([]);
            break;
          case "P":
          // There’s no standard markdown representation for these, but putting them
          // on separate lines is better than jamming them together in a single
          // paragraph.
          case "DL":
          case "DT":
            receiver = new P([]);
            break;
          case "BLOCKQUOTE":
            receiver = new Blockquote([]);
            break;
          case "TT":
          case "CODE":
            receiver = new Code([]);
            break;
          case "BR":
            receiver = new Br([]);
            break;
        }
        if (irNode !== receiver) irNode.push(receiver);

        // Recurse
        for (let i = 0; i < htmlNode.childNodes.length; i++) {
          const c = htmlNode.childNodes[i];
          parse1(receiver, c);
        }
      }
    }

The result is a tree, a lot like the DOM tree, but with only about a dozen
possible node types, only three of which can have any attributes.

<DemoUntransformedIntermediate/>

### Tree transforms

Now that we’re getting closer to markdown, we can perform some operations
directly on the Ir tree, without moving to a new representation.

Here are some examples of tree transform functions from
`src/tree-transforms.ts`.

  - Turn things that started out as `<pre><code>…</code></pre>` into plain
    Preformatted Ir nodes, without an inner Code node.

    Markdown has two different kinds of code blocks: *inline
    code*, <code>&#96;foo&#96;</code>, normally rendered as <code>&lt;code
    …/&gt;</code>, and *code blocks*, typically designated with a
    four-space-indent inside markdown source

        function foo () {
            ...
        }

    that gets rendered into HTML as `<pre><code>…</code></pre>`.

    When going from HTML to markdown, `<code>` should turn
    into <code>&#96;foo&#96;</code>, and 2md has a Code class to represent
    inline code. Meanwhile HTML of the form `<pre><code>…</code></pre>`
    should turn into a Preformatted Ir node, with no Code object,
    to represent a code *block*.

    The initial Ir tree comes from a fairly direct mapping of HTML tags, so
    also ends up with a Code node as a child of a Preformatted node.
    There’s no need for that, and we don’t want to emit four-space-indented
    blocks with an extra <code>&DiacriticalGrave;</code> in there,
    so that should be simplified.

    The code to do that is

        function collapseCodeInsidePre(node: IrNode) {
          if (node.name !== "Preformatted") {
            return;
          }

          if (node.childCount() === 1) {
            const c = node.child(0);
            if (typeof c !== "string" && c.name === "Code") {
              node.replaceChildWithItsChildren();
            }
          }
        }

    which is called from a wrapper function that handles the traversal
    boilerplate.

  - For `<ul><li>…` markup we can emit `"  - "` markdown without regard for the
    context surround where the `<li>` occurs.

    But for an `<li>` inside an `<ol>`, we need to emit a number
    corresponding to the index in the parent list.

    So there’s a `numberLists` transform which walks along, counting, and
    sets the correct `index` attribute on every NumberedListItem.

  - Concatenate adjacent string children into a single string, purely to
    make it easier to understand what is going on. This is especially
    noticeable for the syntax highlighting in the ‘Node JS’ and ‘Stack
    Overflow’ examples, where each `<span … />` for syntax highlighting
    ends up being a separate string without this optimization.

        /**
         * If two subsequent nodes are strings, concatenate them. This optimization pass
         * should be quick, and is here entirely to make unit test input cleaner.
         */
        function concatenateStrings(node: IrNode) {
          for (let i = 0; i < node.childCount() - 1; i++) {
            const c0 = node.child(i);
            const c1 = node.child(i + 1);
            if (typeof c0 === "string" && typeof c1 === "string") {
              node.setChild(i, c0 + c1);
              node.removeChild(i + 1);
              // Since we just deleted the element at the current index, decrement
              // the loop index, otherwise we’ll miss the next element which has
              // shifted down into the current position.
              i--;
            }
          }
        }

With all that and more, the output is the same Ir tree as before, now a bit
more markdown-ish.

<DemoIntermediate/>

We’re almost ready for output!

### OutputBlocks

There’s one final important thing that Ir objects have: a `render()`
method. This is how the Ir tree gets turned into something much closer to
markdown.

All the Ir classes are defined in `src/2md.ts`, and here’s one of them:

    export class Code extends IrNode {
      static irName: NodeName = "Code";

      render(r: BlockRendering) {
        r.append("`");
        super.render(r);
        r.append("`");
      }
    }

Pretty easy! To output an inline code block: output a <code>&#96;</code>
character, call the superclass `render()` method to render any children of
this node, and then output another <code>&#96;</code> character.

That example uses inline markdown. What about a block?

    export class ListItem extends IrNode {
      static irName: NodeName = "ListItem";

      render(r: BlockRendering) {
        const prefix = new Prefix("  - ", "    ");
        r.pushPrefix(prefix);
        super.render(r);
        r.popPrefix(prefix);
      }
    }

Pretty straightforward: add a Prefix of `"  - "` for the first line of the
bullet point and `"    "` for subsequent lines, recursively render the
`IrNode`’s contents, then stop using that Prefix since the block is done.

The interface for `BlockRendering` is pretty small:

    export declare class BlockRendering {
      append(s: string, newline?: boolean): void;
      pushPrefix(prefix: Prefix, wrapOptions?: BlockOptions): void;
      popPrefix(prefix: Prefix): void;
      /** Used for collecting link info to add on at the end */
      addTrailer(s: string): void;

      finish(): string;
    }

At this point, it may look like it’s possible to write out the final
markdown string, but my attempts at that were problematic. Sure, a lot of
html can be correctly handled that way, but there is an issue that requires
more structure to handle.

Nesting. Nesting gets complicated.

For example, if there’s a code block in a bulleted list inside a
blockquote, the start of the line is

    >   -     foo

which renders back to HTML as

>   -     foo

but if that same code block starts on a later line of the bullet point,
there’s no bullet-point marker on the same line as the start of the code
block:

    >   - Here is some code:
    >
    >         foo
    >
    > …

and that renders back to HTML as

>   - Here is some code:
>
>         foo
>
> …

The render function inside the Code class doesn’t and shouldn’t know
whether it’s on the first line of a bullet point item or not.

After trying out a number of unsuccessful hacks, I decided that the issue
was complicated enough to justify introducing a new intermediate
representation called an OutputBlock, roughly corresponding to a paragraph.

Instead of `IrNode.render()` appending to the final markdown string, it
writes into an OutputBlock object. A new OutputBlock automatically gets
created whenever the Prefix changes.

Each OutputBlock contains two key things:

  - block content in the form of a string that’s already markdown

  - a stack of Prefix objects tracking what needs to be inserted at the
    beginning of each line

The Prefix class is fairly simple: the text to use on the first line, the
text to use on subsequent lines, and whether or not it’s already been
rendered.

    /**
     * A string that gets prepended to each line of an output block in Markdown,
     * e.g., `#` or `>`. The first line is often different from subsequent lines,
     * for example with a bulleted list that is simply indented on subsequent lines.
     *
     * You should always make a new prefix instead of caching one, because it
     * contains state to track whether the first line has been printed or not.
     */
    export class Prefix {
      readonly first: string;
      readonly subsequent: string;
      private _rendered = false;

      constructor(first: string, subsequent?: string) {
        this.first = first;
        this.subsequent = subsequent !== undefined ? subsequent : first;
      }

      equals(other: Prefix): boolean {
        return this.first === other.first && this.subsequent === other.subsequent;
      }

      static render(prefixStack: Prefix[]): string {
        let ret = "";
        for (let p of prefixStack) {
          if (!p._rendered) {
            p._rendered = true;
            ret += p.first;
          } else {
            ret += p.subsequent;
          }
        }
        return ret;
      }
    }

With this structure, we can be sure that when a block, for example a bullet
point, requires a different line-start on its first line, that first line
is definitely used, and only once. Even if there’s a lot of deep nesting.

Here’s that OutputBlock representation, which is much much closer to
finally being markdown:

<DemoOutputBlocks/>

The structure here is usually pretty boring because there’s usually not a
lot of nesting in typical documents, but is particularly noticeable on the
‘Nested lists’ example.

Any `""` prefix blocks are used as paragraph markers; empty lines will
later be emitted at the end of every output block.

By the way, any links here haven’t been lost; they’re stored in the object
that holds the `OutputBlocks[]` list, and will be appended at the end of
the final markdown text.

### Markdown

After wrapping the text in each OutputBlock, and prepending the prefix to
each line—finally we have markdown!

<DemoMarkdown/>

</DemoFlow>

<div className="clearfix"/>

## The development process

2md, and the details I’ve given about how it works, didn’t pop into myj
head (or out of it into my computer) fully formed. I’m sharing the
development process here in the hopes that it might help you get started on
something too.

To start, I chose one clipping, the Ars Technica excerpt above, by
scrolling through the last article I’d manually clipped something out of,
looking for a small piece with a good variety of formatting. It has a
heading, bold text, links, bullet points, and nothing else. Something
simple to start.

Then I worked on the Ir stuff to pass a single unit test to turn that
document into Ir nodes:

    it("can parse the first sample", async function() {
      const html = await fixture("quote1.html");
      const expected = new Document([
        new Heading(["The end of 32-bit apps (and other removals)"], {
          level: 2
        }),

        new P([
          "Mac hardware and macOS made the jump from 32 bits to 64 bits a long" +
          ...

with the expectation that those Ir nodes could then append their contents
to a string. But I didn’t try to do anything on that front until that first
unit test passed. Then I added rendering of Ir into a string, including
text wrapping.

Once that worked end-to-end, again with just headings, bold, links, and
bullet points, I knew I was on the right track.

At this point I took some time to add a readme, commented the code a bit,
wrote a launcher script, and pushed everything to GitHub. I poked a few
people who might be interested in working on it with me, and though nobody
was interested enough to start writing code, I did receive encouragement.

I’d been trying to use the code while working on it, and that was clearly
showing me where it needed work. For example, the MDN excerpt got into the
test suite because, when looking up how to do some basic thing with regular
expressions, 2md did a terrible job of pasting what I found into my notes.

Every time I used it, I’d notice things it needed, and worked down the list
adding support for them until they were pretty much all taken care of. Some
were easy, like adding italics support by copying the code for bold and
changing a handful of characters; others, like figuring out how to handle
nested lists, were much more work.

As far as testing goes, one big advantage here over typical
compiler-writing is that there are a lot of existing tools to turn markdown
into HTML, so it’s easy to create end-to-end test cases. I could write test
cases in markdown, have the test convert that to HTML using some existing
library, and verify that 2md would turn that HTML back into the original
markdown. There’s certainly no tool for C compiler writers that turns
binaries back into source code in a way that validates the correctness of
the compiler’s code generation.

Incidentally, that means that my knowledge here might be obsolete in the
sense that this might be a very good problem for machine learning:
existing markdown-to-html libraries can generate vast amounts of training
data for learning a model to go in the opposite direction.

In this case, I did things the old-fashioned way, looking at text dumps of
data structures on the terminal to figure out where things were going
wrong, and inventing new data structures and algorithms to make things go
right. 2md has a `--output-format` flag for debugging; it dumps text
versions of the structures in this post. I didn’t have interactive
in-browser data structures at the start, but now that I’ve learned how, I’d
likely try to get those in from the beginning.

### JavaScript

This project is written in JavaScript and I would argue that it should be
the default language for most projects for most people. Actual webapps, of
course, but also scripting, automation, little throwaway command-line
utilities: do it all in JavaScript.

Why?

To start, there are some convenient things about working with node.

The node.js project provides static relocatable binaries for almost every
platform, including Raspberry Pi, so it’s fast and easy to get any
supported version of node running on almost any machine, even if you don’t
have root access. It’s just `wget https://… && tar …`.

And those packages include `npx` which makes it really easy to run tools
off of npm; `npx 2md` should just work anywhere. Need any tool at all on
some machine you’re SSHed into, says a curses json file explorer? `npm fx`.

But outside the command-line world there is the browser. Which is how most
people use software.

If your goal is to build software that other people actually use, you might
as well make something where people can click a link and immediately start
using it. If your users would benefit from interactivity or visuals or
networking of some sort, make it a webpage with JavaScript. If you want to
have interactivity or visuals or remote access when debugging the internals
of your own stuff, write it in JavaScript to begin with so that you can get
those without having to rewrite it in a new programming language.

I built 2md primarily as a command-line program with the intent of later
enabling it to work in a browser. Doing so was pretty anti-climactic. I had
to clean up some dependencies so it wasn’t trying to touch the filesystem,
but that was pretty much it.

#### TypeScript

## Conclusion

This was meant to be a fun challenge that produced something useful for me,
and I’m very happy with how it’s turned out.

I’ve mapped the 2md binary to typing `,2` in vim normal mode (`map ,2
:r!2md <CR>` in `~/.vimrc`) so that pasting markdown in the terminal is
just two keystrokes and a fraction of a second, and I seem to run it on
average 3 or 4 times a day.

It’s not complete by any means; although I’ve covered the most common
formatting that I tend to copy and paste, there’s a lot of room for
improvement. When I notice something off in the markdown output when
running 2md, I save the input (`2md --output-format=raw`) to a folder for
future fixes, and do minor manual fixups to avoid shifting focus from the
task at hand to working on 2md. But if other people are interested in this
tool, I could definitely start working through those samples…

Actually, when the markdown output looks funny, often it’s because the
input HTML is a bit off, e.g., `<b>Hello </b>world` comes out as `**Hello
**world`. That’s something 2md could clean up automatically, and I might do
that some time, as well as taking a look at some parsing the styles, so
that some day `<span style="…; font-weight: bold; …">foo</span>` comes out
as `**foo**`.

This feels like the first project I’ve done that’s really, really easy for
other people to use, setup/installation-wise: just click a link and get
something interactive. For the ability to give people that, I will
definitely use more TypeScript in the future.

In case you’re curious about time: it was about a week of full-time work to
get an initial version with good coverage of markdown features, including
nested lists. It took less than a day to get it running on the web, and
that was mostly dealing with tooling. Dealing with command-line speed
issues was under a day. Windows clipboard support by itself was close to
two days, and now talk preparation / article writing is getting close to
two weeks.

Relating back to the quote from Neal Ford on automation: instead of getting
bored adding markdown formatting over and over by hand, I learned a ton
automating the process, and I’m really, really happy about that. In fact
the hard part now is resisting the urge to simultaneously explore all the
new avenues this has opened up.

— Andrew.

</div>
