<!-- Copyright Â© 2020 Andrew Neitsch all rights reserved. -->

import { PauseableImage } from './pauseable-image';
import {
  DemoCharCount,
  DemoContent,
  DemoDom,
  DemoFlow,
  DemoHtmlEditor,
  DemoIntermediate,
  DemoMarkdown,
  DemoOutputBlocks,
  DemoUntransformedIntermediate,
} from "./demo-flow.tsx";

<div className="container-fluid px-0">
  <div className="jumbotron">

# Compiling HTML to Markdown with TypeScript
## How [2md][] works
[2md]: https://2md.ca

  </div>
</div>

<div className="container">

[*2020-04-04: Iâ€™d been hoping to give this as a talk at a local developer
conference today, but since that was cancelled, Iâ€™ve written this article
instead.*]

2md is a tool I built so that I could copy-and-paste from browsers into
plain-text files, while preserving a lot of the formatting by automatically
converting the HTML to markdown.

It works on mac, linux, and windows, reading HTML off the clipboard from
the command line. You can see source code and install instructions [on
GitHub][2md-github].

[2md-github]: https://github.com/andrewdotn/2md

<figure className="figure">
  <PauseableImage src="/doc/demo.gif" className="figure-img img-fluid rounded"/>
  <figcaption className="figure-caption">
    Copying from the browser and getting markdown in the macOS terminal.<br/>
    Click or tap to pause animation.
  </figcaption>
</figure>

Since I wrote it in TypeScript, it works in the browser too, so you can
even try it out right here on this page.

<DemoFlow>

<DemoContent/>
<div className="clearfix"/>

2md turns the markup for that into this markdown:

<DemoMarkdown/>
<div className="clearfix"/>

# How 2md works

In this article, Iâ€™m going to walk through how this code works in case
youâ€™re just curious or want to be able to build something like this
yourself. At some point this would definitely have been beyond my
capabilities, and now itâ€™s relatively straightforward for me. But thereâ€™s
no single place I know of that can help people learn how to do this. Iâ€™m
hoping to fill that gap a bit.

Iâ€™m also going to talk about why I think TypeScript is great.

And Iâ€™m going to cover some pretty gritty low-level programming details; a
lot of learning is the accumulation of low-level tricks over many years. I
love reading about those tricks in case they come in handy some day, and
enjoy sharing them too.

<!-- wrapper is used to target styling for toc headings -->
<div className="toc">

### Table of Contents

<!--
  -- the div end has to come after the next header because remark-toc
  -- replaces everything in this section with the table of contents
  -->

## Motivation
</div>

For many years Iâ€™ve kept a terminal open in one corner of the
screen where I make notes in a text editor while I work. Itâ€™s sort of like
talking to myself while I work, but it doesnâ€™t seem weird because itâ€™s
silent, and I end up with a searchable, timestamped record of what I was
thinking while I was working on something: what issues I was running into
when programming, the options I considered, sources I consulted, and the
resolution I ultimately arrived at.

When my work involves bits of research, I often copy and paste relevant
snippets from web sources such as [Oâ€™Reilly books][], Stack Overflow,
documentation, source code, and so on. In the moment itâ€™s really handy to
be able to glance at the corner of the screen to see the most pertinent
documentation excerpts. Then later, I often run into an error message that
seems familiar, and am able to search upwards in my notes to find the
context around where I ran into that error message before, and the relevant
snippet that explains how to fix it.

[Oâ€™Reilly books]: https://learning.oreilly.com/

As Iâ€™ve gotten used to markdown over the years, my text notes have taken on
a markdown-ish flavour. You have to know how to use markdown to contribute
on Stack Overflow or write pull request descriptions on GitHub. And once
you know it, it becomes very convenient for general writing about
programming: itâ€™s faster and easier to type and read and diff than raw
HTML. So I naturally started using it not only for writing things like this
article, but also in my notes. My notes arenâ€™t all markdown because they go
back many any years and itâ€™s still mostly me talking to myself, but I try
to use it where I can easily do so.

When pasting from the web to a `.txt` file, I found that Iâ€™d started
manually massaging what Iâ€™d pasted to make it markdown-ish.

  - Adding `>` characters at the start to clearly distinguish quotes from
    my own thoughts.
  - Wrapping the text to fit in 80 columns.
  - Separating out bullet points into little text lists.
  - Preserving *italics* where important.
  - Inserting hyperlinks.

After doing this a bunch of times, I started to think, â€œSurely I can
automate this.â€ And I was probably doing this a few times a day, just a
moment or two of rearranging a handful of lines of text in my text editor,
but getting those regular reminders saying, â€œI can automate this.â€

Neal Ford in [The Productive Programmer][], discussing automation,
describes that when weighing whether to do a task via brute force or to
spend time and effort automating it, while automation often pays off
time-wise,

[The Productive Programmer]: https://learning.oreilly.com/library/view/the-productive-programmer/9780596519780/ch04.html#I_sect13_d1e5404

> â€¦ thatâ€™s not the important point. Performing simple, repetitive tasks
> by hand makes you dumber, and it steals part of your concentration, which
> is your most productive asset.
>
> Figuring out a clever way to automate the task makes you smarter because
> you learn something along the way.

One day I let these constant reminders get through to me, started
automating it, and am really glad I did.

### Related work

I built this for myself as a fun challenge, never pausing to consider
whether it already existed until after Iâ€™d coded it up myself from scratch.

It wasnâ€™t until the initial version was working pretty well and I was
updating the project description on the GitHub page that I saw that were
was already an [html-to-markdown tag][] on GitHub with lots of projects,
many already written in JavaScript.

[html-to-markdown tag]: https://github.com/topics/html-to-markdown

The [turndown][] project is the big one; if you want a much more mature
html-to-markdown tool, you might want to take a look at that.

[turndown]: https://github.com/domchristie/turndown

And then many months later I was mortified to find that
[github.com/phodal/2md][] and [github.com/zshipu/2md][] had already existed
for three years, with an interactive web version at
[phodal.github.io/2md/][]! Same name and everything. Oops.Â When I saw that
the `2md` package name was free on [npm][], I assumed that the name `2md`
was totally original. And by the time I found out it wasnâ€™t, Iâ€™d gotten
attached to the name for my project over many months, and wasnâ€™t up for
changing it.

[github.com/phodal/2md]: https://github.com/phodal/2md
[github.com/zshipu/2md]: https://github.com/zshipu/2md
[phodal.github.io/2md/]: https://phodal.github.io/2md/
[npm]: https://www.npmjs.com

Also someone had asked for almost exactly what I built in a [2013 Stack
Overflow question][], so itâ€™s definitely not an original idea.

[2013 Stack Overflow question]: https://stackoverflow.com/q/16953581/14558

## Overview

The general bodies of theory drawn from here are programming language
compilation, data structures, and graph theory. Mostly itâ€™s about the
graphs of data structures typical of the middle stages inside a compiler.
But thereâ€™s a lot of compiler theory thatâ€™s not really relevant for this
project: weâ€™re not implementing any lexing ourselves, and thereâ€™s no
register allocation or anything.

To help make the problem manageable, weâ€™re going to rely on two
complementary principles:

#### <small>Principle 1:</small><br/> Instead of working with strings, work with objects

Why not go directly from HTML to markdown? You might be thinking regular
expressions would be a good start, turning `<b>â€¦</b>` into `**â€¦**` and so
on. And indeed a sufficiently motivated person could get surprisingly far
doing that. But things will get complicated quickly, with lots of corner
cases, and youâ€™ll end up with too much going on at once.

An example of this sort of an approach: in some HTML, to update the CSS
class on some div, itâ€™s definitely possible to search for the markup `<div
â€¦ class="â€¦">` and edit the contents. You might need to create the `class`
attribute first if it doesnâ€™t already exist, and youâ€™ll probably want to
handle variations like `class="foo"` vs. `class='foo'` vs. `class=foo`, but
itâ€™s doable.

Although thatâ€™s doable, the code `div.classList.toggle('expanded')` is much
shorter, easier to read and understand, faster to run, and less
error-prone.

Thereâ€™s some cost of parsing the HTML into a data structure and turning it
back into a string at the end, but when there are many operations to
perform, or a desire to handle variations and corner cases, or when you
start to think about the problem of specifying *which* div to operate on;
the increased simplicity and precision of working with objects to perform
all those operations add up to greatly outweigh the cost of parsing the
input into some

By working at this higher level of abstraction we gain precise focus,
much more readable code, and a chance at clean APIs.

In fact the Document Object Model standard aka DOM is a fine data structure
for HTML input, and thatâ€™s what 2md uses for its input stage. Itâ€™s the
default API in browser environments where you also get a free parser by
setting `innerHTML` on elements. `jsdom` provides command-line tools with
the same DOM API as in the browser. And whatever issues the DOM API may
have for HTML, those are made up for many times over by its ubiquity and
familiarity.

#### <small>Principle 2:</small><br/> Transform the input through a sequence of data types

To turn HTML into markdown, weâ€™re going to perform a series of
transformation steps to make it a bit more markdown-like until it
eventually *is* markdown.

<p>
<img className="center-md" src="/doc/flow.svg"/>
</p>

In this transformation sequence, sometimes the output of a step will be the
same as its input typeâ€”thatâ€™s what the loop is indicatingâ€”and sometimes
itâ€™ll be a new output type more suited to future steps.

Though there are many benefits to using the DOM API to represent HTML, itâ€™s
a poor fit for representing markdown. It has a bunch of stuff we donâ€™t
need, like `classList`, and it doesnâ€™t include a bunch of stuff that we do
care about for markdown, like the index of an `<li>` inside an `<ol>`.

So we simplify by introducing a new data structure called an intermediate
representation: something thatâ€™s logically between two other
representations, and has similarities with both but isnâ€™t actually either.

For 2md, the intermediate representation is called `Ir`, and itâ€™s not HTML
anymore, though itâ€™s close, and itâ€™s not quite markdown yet, though itâ€™s
also close. I could have come up with a more descriptive name than
Irâ€”markml? htdown? mdish?â€”but calling it an IR, or IL for â€˜intermediate
language,â€™ is traditional. Sometimes the term â€˜intermediate representationâ€™
gets very confusing if you end up with a bunch of different intermediate
representations inside a compiler, with all of those different
representations having very similar names. For 2md, there is another
intermediate representation called OutputBlocks, but the names are
different enough to avoid confusion.

How many different intermediate representations do you need? Well, it
depends. I started out with two, DOM and Ir, and later added a third called
OutputBlocks when that seemed prudent. Itâ€™s something you learn about the
problem space as you write code that works in it. If the current
representation is getting too complicated, or youâ€™re adding a bunch of
specialized functionality, it makes sense to introduce a new
representation. And sometimes you end up with too many intermediate steps
that are too similar that just waste a lot of time passing the same data
around, and waste your time when youâ€™re trying to find the part where
things actually happen, and you edit the code to reduce the number of
intermediate representations.

Itâ€™s a lot like object-oriented programming, where you often start out with
one class, and then that one class starts doing too many different things,
split it up into different more-focused classes. Except here instead of a
single class, each representation is composed of a whole family of classes.

Incidentally, even if you werenâ€™t working in a vacuum and reused an
existing library like `mdast` to represent the markdown output, I expect
that the code would be easier to write and maintain with an intermediate
representation expect between the DOM and markdown representations.

## Details

All right, finally itâ€™s time to look at some source code excerpts, and some
real live data structures!

Hereâ€™s that selector/paste box again:

<DemoContent/>

### Raw HTML

The raw HTML for these snippets is generally pretty messy:

<DemoHtmlEditor/>

These examples mostly come from copying and pasting from Safari on a mac.
Other browsers seem to be similar, but the important thing is that to make
note of is that, in order to make the snippet self-contained, the browser
took all the computed styles from all the CSS and inlined it on every
element, making the markup really messy. And glomming everything onto one
line makes it a lot harder to read.

Instead of staring at a <DemoCharCount/>-character string, letâ€™s pop it
into a DOM tree to collapse the `style="â€¦"` nodes and reveal the tree
structure.

### DOM tree

Parsing HTML into DOM objects is a very important part of the browserâ€™s
reason for existence, and itâ€™ll just do that naturally if formatted text is
pasted into a `contentEditable` area, at which point your object reference
to the `contentEditable` is your handle into the DOM tree.

To get DOM objects from HTML *strings* inside a browser, you can create a
new document and then set the body HTML:

    const doc = document.implementation.createHTMLDocument();
    doc.body.innerHTML = 'Hello, <b>world</b>';
    doc.documentElement.outerHTML;
    // returns "<html><head></head><body>Hello, <b>world</b></body></html>"

In node.js, the `jsdom` package provides a string-taking constructor
directly, and returns objects with the same API that youâ€™d get in the
browser:

    const { JSDOM } = require('jsdom');
    const doc = new JSDOM('Hello, <b>world</b>').window.document;
    doc.documentElement.outerHTML;
    // returns "<html><head></head><body>Hello, <b>world</b></body></html>"

At this point, youâ€™ve got DOM `Node` objects with familiar APIs like
`node.childNodes`, `node.appendChild()`, `node.replaceChild()`,
`node.nodeType` which has to be compared against various integer constants;
essentially all the stuff that jQuery does behind the scenes.

<DemoDom/>

### Building the intermediate representation

How to start turning that DOM tree into markdown?

Well, thereâ€™s lots that can be thrown away, like any HTML comments, the contents
of any `class=""` attributes; and we donâ€™t care about `<div>`s or `<span>`s; â€¦
in fact weâ€™re going to throw away everything except for text and a small number
of tags, and do some normalization such as mapping both `<i>foo</i>` and
`<em>foo</em>` into the same thing because theyâ€™ll both come out the markdown
end as `*foo*`.

And this is where Ir comes into play: itâ€™s a simplified, normalized data
structure to make the HTML input more markdown-like.

Each Ir node has:

  - A name, and possibly an attribute, from the following list, roughly
    corresponding to the subset of HTML thatâ€™s relevant to generating
    markdown:
      - A (attribute: href)
      - Blockquote
      - Bold
      - Br
      - Code
      - Heading (attribute: level)
      - I
      - ListItem
      - NumberedListItem (attribute: number)
      - OrderedList
      - P
      - Preformatted
      - Document
  - A list of children, all of which are either other Ir nodes or plain
    strings.

The code to actually do this is in `src/parse.ts`:

  - If the current DOM node is text, add it to the current Ir nodeâ€™s
    children
  - If the current DOM node is an â€˜interestingâ€™ HTML tag, create a new Ir node
    for it, and add it as a child of the current Ir node
  - Then recurse down into any child nodes of the current DOM node

The code:

    function parse(doc: Node): IrNode {
      const root = new Document([]);

      for (let i = 0; i < doc.childNodes.length; i++) {
        parse1(root, doc.childNodes[i]);
      }
    }

    // This is the actual recursive function; I think I picked up the naming
    // convention from Lisp. When a recursive function needs accumulators, `foo()`
    // is the simplified API used by callers that does the initial setup, and
    // `foo1()` recurses.
    function parse1(irNode: IrNode, htmlNode: Node) {
      if (
        htmlNode.nodeType == htmlNode.TEXT_NODE &&
        htmlNode.textContent !== null
      ) {
        if (
          htmlNode.textContent !== "\n" ||
          irNode.isOrHasParentNamed("Preformatted")
        ) {
          irNode.push(htmlNode.textContent);
        }
      } else if (htmlNode.nodeType == htmlNode.ELEMENT_NODE) {
        const e = <Element>htmlNode;
        let receiver = irNode;
        switch (htmlNode.nodeName) {
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
            receiver = new Heading([], {
              level: extractHeadingLevel(htmlNode.nodeName)
            });
            break;
          case "B":
          case "STRONG":
            receiver = new Bold([]);
            break;
          case "I":
          case "EM":
            receiver = new I([]);
            break;
          case "OL":
            receiver = new OrderedList([]);
            break;
          case "LI":
            receiver = new ListItem([]);
            break;
          case "A":
            const href = e.getAttribute("href");
            if (href) {
              receiver = new A([], { href });
            }
            break;
          case "PRE":
            receiver = new Preformatted([]);
            break;
          case "P":
          // Thereâ€™s no standard markdown representation for these, but putting them
          // on separate lines is better than jamming them together in a single
          // paragraph.
          case "DL":
          case "DT":
            receiver = new P([]);
            break;
          case "BLOCKQUOTE":
            receiver = new Blockquote([]);
            break;
          case "TT":
          case "CODE":
            receiver = new Code([]);
            break;
          case "BR":
            receiver = new Br([]);
            break;
        }
        if (irNode !== receiver) irNode.push(receiver);

        // Recurse
        for (let i = 0; i < htmlNode.childNodes.length; i++) {
          const c = htmlNode.childNodes[i];
          parse1(receiver, c);
        }
      }
    }

The result is a tree, a lot like the DOM tree, but with only about a dozen
possible node types, only three of which can have any attributes.

<DemoUntransformedIntermediate/>

### Tree transforms

Now that weâ€™re getting closer to markdown, we can perform some operations
directly on the Ir tree, without moving to a new representation.

Here are some examples of tree transform functions from
`src/tree-transforms.ts`.

  - Turn things that started out as `<pre><code>â€¦</code></pre>` into plain
    Preformatted Ir nodes, without an inner Code node.

    Markdown has two different kinds of code blocks: *inline
    code*, <code>&#96;foo&#96;</code>, normally rendered as <code>&lt;code
    â€¦/&gt;</code>, and *code blocks*, typically designated with a
    four-space-indent inside markdown source

        function foo () {
            ...
        }

    that gets rendered into HTML as `<pre><code>â€¦</code></pre>`.

    When going from HTML to markdown, `<code>` should turn
    into <code>&#96;foo&#96;</code>, and 2md has a Code class to represent
    inline code. Meanwhile HTML of the form `<pre><code>â€¦</code></pre>`
    should turn into a Preformatted Ir node, with no Code object,
    to represent a code *block*.

    The initial Ir tree comes from a fairly direct mapping of HTML tags, so
    also ends up with a Code node as a child of a Preformatted node.
    Thereâ€™s no need for that, and we donâ€™t want to emit four-space-indented
    blocks with an extra <code>&DiacriticalGrave;</code> in there,
    so that should be simplified.

    The code to do that is

        function collapseCodeInsidePre(node: IrNode) {
          if (node.name !== "Preformatted") {
            return;
          }

          if (node.childCount() === 1) {
            const c = node.child(0);
            if (typeof c !== "string" && c.name === "Code") {
              node.replaceChildWithItsChildren();
            }
          }
        }

    which is called from a wrapper function that handles the traversal
    boilerplate.

  - For `<ul><li>â€¦` markup we can emit `"Â Â -Â "` markdown without regard for the
    context surround where the `<li>` occurs.

    But for an `<li>` inside an `<ol>`, we need to emit a number
    corresponding to the index in the parent list.

    So thereâ€™s a `numberLists` transform which walks along, counting, and
    sets the correct `index` attribute on every NumberedListItem.

  - Concatenate adjacent string children into a single string, purely to
    make it easier to understand what is going on. This is especially
    noticeable for the syntax highlighting in the â€˜Node JSâ€™ and â€˜Stack
    Overflowâ€™ examples, where each `<span â€¦ />` for syntax highlighting
    ends up being a separate string without this optimization.

        /**
         * If two subsequent nodes are strings, concatenate them. This optimization pass
         * should be quick, and is here entirely to make unit test input cleaner.
         */
        function concatenateStrings(node: IrNode) {
          for (let i = 0; i < node.childCount() - 1; i++) {
            const c0 = node.child(i);
            const c1 = node.child(i + 1);
            if (typeof c0 === "string" && typeof c1 === "string") {
              node.setChild(i, c0 + c1);
              node.removeChild(i + 1);
              // Since we just deleted the element at the current index, decrement
              // the loop index, otherwise weâ€™ll miss the next element which has
              // shifted down into the current position.
              i--;
            }
          }
        }

With all that and more, the output is the same Ir tree as before, now a bit
more markdown-ish.

<DemoIntermediate/>

Weâ€™re almost ready for output!

### OutputBlocks

Thereâ€™s one final important thing that Ir objects have: a `render()`
method. This is how the Ir tree gets turned into something much closer to
markdown.

All the Ir classes are defined in `src/2md.ts`, and hereâ€™s one of them:

    export class Code extends IrNode {
      static irName: NodeName = "Code";

      render(r: BlockRendering) {
        r.append("`");
        super.render(r);
        r.append("`");
      }
    }

Pretty easy! To output an inline code block: output a <code>&#96;</code>
character, call the superclass `render()` method to render any children of
this node, and then output another <code>&#96;</code> character.

That example uses inline markdown. What about a block?

    export class ListItem extends IrNode {
      static irName: NodeName = "ListItem";

      render(r: BlockRendering) {
        const prefix = new Prefix("  - ", "    ");
        r.pushPrefix(prefix);
        super.render(r);
        r.popPrefix(prefix);
      }
    }

Pretty straightforward: add a Prefix of `"Â Â -Â "` for the first line of the
bullet point and `"Â Â Â Â "` for subsequent lines, recursively render the
`IrNode`â€™s contents, then stop using that Prefix since the block is done.

The interface for `BlockRendering` is pretty small:

    export declare class BlockRendering {
      append(s: string, newline?: boolean): void;
      pushPrefix(prefix: Prefix, wrapOptions?: BlockOptions): void;
      popPrefix(prefix: Prefix): void;
      /** Used for collecting link info to add on at the end */
      addTrailer(s: string): void;

      finish(): string;
    }

At this point, it may look like itâ€™s possible to write out the final
markdown string, but my attempts at that were problematic. Sure, a lot of
html can be correctly handled that way, but there is an issue that requires
more structure to handle.

Nesting. Nesting gets complicated.

For example, if thereâ€™s a code block in a bulleted list inside a
blockquote, the start of the line is

    >   -     foo

which renders back to HTML as

>   -     foo

but if that same code block starts on a later line of the bullet point,
thereâ€™s no bullet-point marker on the same line as the start of the code
block:

    >   - Here is some code:
    >
    >         foo
    >
    > â€¦

and that renders back to HTML as

>   - Here is some code:
>
>         foo
>
> â€¦

The render function inside the Code class doesnâ€™t and shouldnâ€™t know
whether itâ€™s on the first line of a bullet point item or not.

After trying out a number of unsuccessful hacks, I decided that the issue
was complicated enough to justify introducing a new intermediate
representation called an OutputBlock, roughly corresponding to a paragraph.

Instead of `IrNode.render()` appending to the final markdown string, it
writes into an OutputBlock object. A new OutputBlock automatically gets
created whenever the Prefix changes.

Each OutputBlock contains two key things:

  - block content in the form of a string thatâ€™s already markdown

  - a stack of Prefix objects tracking what needs to be inserted at the
    beginning of each line

The Prefix class is fairly simple: the text to use on the first line, the
text to use on subsequent lines, and whether or not itâ€™s already been
rendered.

    /**
     * A string that gets prepended to each line of an output block in Markdown,
     * e.g., `#` or `>`. The first line is often different from subsequent lines,
     * for example with a bulleted list that is simply indented on subsequent lines.
     *
     * You should always make a new prefix instead of caching one, because it
     * contains state to track whether the first line has been printed or not.
     */
    export class Prefix {
      readonly first: string;
      readonly subsequent: string;
      private _rendered = false;

      constructor(first: string, subsequent?: string) {
        this.first = first;
        this.subsequent = subsequent !== undefined ? subsequent : first;
      }

      equals(other: Prefix): boolean {
        return this.first === other.first && this.subsequent === other.subsequent;
      }

      static render(prefixStack: Prefix[]): string {
        let ret = "";
        for (let p of prefixStack) {
          if (!p._rendered) {
            p._rendered = true;
            ret += p.first;
          } else {
            ret += p.subsequent;
          }
        }
        return ret;
      }
    }

With this structure, we can be sure that when a block, for example a bullet
point, requires a different line-start on its first line, that first line
is definitely used, and only once. Even if thereâ€™s a lot of deep nesting.

Hereâ€™s that OutputBlock representation, which is much much closer to
finally being markdown:

<DemoOutputBlocks/>

The structure here is usually pretty boring because thereâ€™s usually not a
lot of nesting in typical documents, but is particularly noticeable on the
â€˜Nested listsâ€™ example.

Any `""` prefix blocks are used as paragraph markers; empty lines will
later be emitted at the end of every output block.

By the way, any links here havenâ€™t been lost; theyâ€™re stored in the object
that holds the `OutputBlocks[]` list, and will be appended at the end of
the final markdown text.

### Markdown

After wrapping the text in each OutputBlock, and prepending the prefix to
each lineâ€”finally we have markdown!

<DemoMarkdown/>

</DemoFlow>

<div className="clearfix"/>

## The development process

2md, and the details Iâ€™ve given about how it works, didnâ€™t pop into myj
head (or out of it into my computer) fully formed. Iâ€™m sharing the
development process here in the hopes that it might help you get started on
something too.

To start, I chose one clipping, the Ars Technica excerpt above, by
scrolling through the last article Iâ€™d manually clipped something out of,
looking for a small piece with a good variety of formatting. It has a
heading, bold text, links, bullet points, and nothing else. Something
simple to start.

Then I worked on the Ir stuff to pass a single unit test to turn that
document into Ir nodes:

    it("can parse the first sample", async function() {
      const html = await fixture("quote1.html");
      const expected = new Document([
        new Heading(["The end of 32-bit apps (and other removals)"], {
          level: 2
        }),

        new P([
          "Mac hardware and macOS made the jump from 32 bits to 64 bits a long" +
          ...

with the expectation that those Ir nodes could then append their contents
to a string. But I didnâ€™t try to do anything on that front until that first
unit test passed. Then I added rendering of Ir into a string, including
text wrapping.

Once that worked end-to-end, again with just headings, bold, links, and
bullet points, I knew I was on the right track.

At this point I took some time to add a readme, commented the code a bit,
wrote a launcher script, and pushed everything to GitHub. I poked a few
people who might be interested in working on it with me, and though nobody
was interested enough to start writing code, I did receive encouragement.

Iâ€™d been trying to use the code while working on it, and that was clearly
showing me where it needed work. For example, the MDN excerpt got into the
test suite because, when looking up how to do some basic thing with regular
expressions, 2md did a terrible job of pasting what I found into my notes.

Every time I used it, Iâ€™d notice things it needed, and worked down the list
adding support for them until they were pretty much all taken care of. Some
were easy, like adding italics support by copying the code for bold and
changing a handful of characters; others, like figuring out how to handle
nested lists, were much more work.

As far as testing goes, one big advantage here over typical
compiler-writing is that there are a lot of existing tools to turn markdown
into HTML, so itâ€™s easy to create end-to-end test cases. I could write test
cases in markdown, have the test convert that to HTML using some existing
library, and verify that 2md would turn that HTML back into the original
markdown. Thereâ€™s certainly no tool for C compiler writers that turns
binaries back into source code in a way that validates the correctness of
the compilerâ€™s code generation.

Incidentally, that means that my knowledge here might be obsolete in the
sense that this might be a very good problem for machine learning:
existing markdown-to-html libraries can generate vast amounts of training
data for learning a model to go in the opposite direction.

In this case, I did things the old-fashioned way, looking at text dumps of
data structures on the terminal to figure out where things were going
wrong, and inventing new data structures and algorithms to make things go
right. 2md has a `--output-format` flag for debugging; it dumps text
versions of the structures in this post. I didnâ€™t have interactive
in-browser data structures at the start, but now that Iâ€™ve learned how, Iâ€™d
likely try to get those in from the beginning.

### JavaScript

*[The next few subsections are more opinion-based, skip ahead to <a
href="#complexities">the next section</a> if youâ€™d like to stick to the
technical bits.]*

This project is written in JavaScript and I suggest that it should be the
default language for most projects for most people. For actual webapps, of
course, which is hardly a controversial opinion; but also scripting,
automation, little throwaway command-line utilities: do it all in
JavaScript.

Why?

To start, there are some convenient things about working with node.

The node.js project provides static relocatable binaries for almost every
platform, including Raspberry Pi, so itâ€™s fast and easy to get any
supported version of node running on almost any machine, even if you donâ€™t
have root access. Itâ€™s just `wget https://â€¦ && tar â€¦`, even for the very
latest versions.

And those distributions of node include `npx` which makes it really easy to
run tools off of npm; `npx 2md` should just work anywhere. Need any tool at
all on some random machine youâ€™re SSHed into, like maybe a curses json file
explorer? `npm fx`. Write your tools in JavaScript and it can be that easy
for others to use your software too.

But outside the command-line world there is the browser. Which is how most
people use software.

If your goal is to build software that other people actually use, you might
as well make something where people can click a link and immediately start
using it. If your users would benefit in some way from interactivity or
visuals or networking, use JavaScript and make it a webpage. If you want to
have interactivity or visuals, even for inspecting the internals of your
program, or if you might want somebody to be able to remotely perform an
action using your software some day, write it in JavaScript to begin with
so that you can later add those benefits without having to rewrite
everything in a new programming language.

I built 2md primarily as a command-line program with the intent of later
enabling it to work in a browser. Doing so was pretty anti-climactic. I had
to tidy up some dependency references so it wasnâ€™t trying to touch the
filesystem, but that was pretty much it.

### TypeScript

TypeScript is a popular variant of JavaScript that adds type annotations to
JavaScript. 2md is written in TypeScript, and I found it really useful for
its linting capabilities.

I think I can explain, in fairly simple terms, why using types appeals to
me so much. I make mistakes when Iâ€™m coding. Itâ€™s unavoidable. Weâ€™re taking
vague, uncertain ideas and trying to turn them into precise instructions
for unforgiving machines. I believe something is precise, but not until I
try to make the code work do I find out that it is not, and I will need to
think about it more to get it right.

Thereâ€™s a whole class of low-level bug-inducing detail that is really easy
for machines to catch and really easy for humans to miss. Letâ€™s let them
help us by letting them do that.

  - â€œâ€˜BlockQuoteâ€™ is not a valid option here, but â€˜Blockquoteâ€™ is.â€

  - â€œYou are trying to give a number to a function that says it only
    accepts strings.â€

  - â€œWhat would you like to have happen if `undefined` is passed to this
    functionâ€”surely you do not wish the program to crash in the event of
    such an occurrence?â€

  - â€œIf you add an argument to this function signature, as you are surely
    already aware, you are going to have to update these twelve callers of
    the function. I have highlighted them for you.â€

Thank you, computer. That was very helpful.

Using TypeScript helped give me confidence when refactoring. The prefix
parameter started out as just a string, then was a pair of strings,
eventually becoming its own object that tracks if itâ€™s been rendered yet
and is attached to a new OutputBlock structure. And through every step of
that process, the type-checker showed me all the areas that were affected
by those changes so I could update them appropriately, instead of being
surprised by a easily-detectable error.

There are definitely some drawbacks to TypeScript. It is tricky to learn,
and if someone is just starting out with JavaScript I would actively
discourage working in TypeScript at the start. That way you can learn the
fun of working in JavaScript without risking long fights with corner cases
of the type system. Thereâ€™s only so much you can learn at once, and better
to have some buggy code that mostly works, was fun to write, and can be
cleaned up by adding type-checking later, than a perfectly-typed program
that never grew big enough to be useful.

The TypeScript compiler is intended to do type-checking and then emit
JavaScript code, but Iâ€™ve found using babel to be a much more pleasant
experience for the code-generation part. `@babel/preset-typescript`
essentially throws away all the type annotationsâ€”a very quick
process!â€”leaving you with plain JavaScript to flow through the rest of the
babel pipeline. With `@babel/register`, that happens at runtime, allowing
you to to run `.ts` files directly, without waiting for the typescript
compiler, and even if they have type errors because youâ€™re experimenting.

And the 800-lb gorilla in the room is Microsoft, the corporate sponsor of
TypeScript. As the topic of Microsoftâ€™s history, present, and possible
futures is something much bigger than I am able to go into right now, I
will keep things relatively short. While I find TypeScript highly useful, I
expect Microsoftâ€™s primary overriding long-term motivation to always be
economic, and that does not align with indefinitely spending a lot of money
giving away valuable things.

Please donâ€™t interpret my use of TypeScript (or React or
Bootstrap) as an endorsement of any of Microsoftâ€™s (or Facebookâ€™s or
Twitterâ€™s) products, services, business practices, or impacts on society.

Should the powers-that-be at Microsoft some day decide that TypeScript no
longer makes financial sense to continue to invest in, at least we will
have the option of dropping all the types from our code and going on with
JavaScript alone. Type systems for JavaScript and dialects of JavaScript
will come and go, but JavaScript itself will remain highly relevant for a
very long time.

## Complexities

The earlier technical stuff was a reasonably straightforward application of
existing theory on parsing and transforming structured text.

Now we get more into what Fred Brooks Jr. termed accidental complexity:
all the things we have to do to get the problem solved
that arenâ€™t part of any abstract solution,
but are consequences of the tools and conventions we

### Command-line speed

1.6s to 0.6s


adding

  "alias": {
    "canvas": "./src/canvas-shim.js"
  },
  "browserslist": "current node"

### Line wrapping graphemes

did not reinvent wheel

Ã¼ = U+00FC
U+0075 U+0308 â€œCombining Diaeresisâ€

<span class="tex">T<sub>e</sub>X</span>book

ğŸ¦Š
U+1F98A â€œFOX FACEâ€


`ğŸ„ğŸ¾â€â™€ï¸`

  - U+1F3C4 â€˜`ğŸ„`â€™ Surfer
  - U+1F3FE â€˜`ğŸ¾`â€™ Emoji Modifier [Fitzpatrick][] Type-5
  - U+200D â€˜`â€ï¸`â€™ Zero Width Joiner
  - U+2640 â€˜`â™€ï¸`â€™ Female Sign
  - U+FE0F â€˜`ï¸`â€™ [Variation Selector][]-16



As an extreme case, if you consider

â€˜[`HÍ¨ÍŠÌ½Ì…Ì¾ÌÌ¡Ì¸ÌªÌ¯EÌ¾Í›ÍªÍ„Ì€ÌÌ§Í˜Ì¬Ì© Í§Ì¾Í¬Ì§Ì¶Ì¨Ì±Ì¹Ì­Ì¯CÍ­ÌÍ¥Í®ÍŸÌ·Ì™Ì²ÌÍ–OÍ®ÍÌ®ÌªÌÍMÍŠÌ’ÌšÍªÍ©Í¬ÌšÍœÌ²Ì–EÌ‘Í©ÍŒÍÌ´ÌŸÌŸÍ™ÌSÍ¯Ì¿Ì”Ì¨Í€Ì¥Í…Ì«ÍÌ­`][bobince]â€™

if youâ€™re 

[bobince]: https://stackoverflow.com/a/1732454/14558

  which is 83 UTF-16 code units
  (which JavaScript uses for `String.length`
  158 bytes in UTF-8 but only 0

[Fitzpatrick]: https://en.m.wikipedia.org/wiki/Fitzpatrick_scale
[Variation Selector]: https://en.wikipedia.org/wiki/Miscellaneous_Symbols#Emoji

5 Unicode code points
7 UTF-16 code units
17 bytes in UTF-8

I just used the grapheme-splitter package

### Windows clipboard

## Conclusion

This was meant to be a fun challenge that produced something useful for me,
and Iâ€™m very happy with how itâ€™s turned out.

Iâ€™ve mapped the 2md binary to typing `,2` in vim normal mode (`map ,2
:r!2md <CR>` in `~/.vimrc`) so that pasting markdown in the terminal is
just two keystrokes and a fraction of a second, and I seem to run it on
average 3 or 4 times a day.

Itâ€™s not complete by any means; although Iâ€™ve covered the most common
formatting that I tend to copy and paste, thereâ€™s a lot of room for
improvement. When I notice something off in the markdown output when
running 2md, I save the input (`2md --output-format=raw`) to a folder for
future fixes, and do minor manual fixups to avoid shifting focus from the
task at hand to working on 2md. But if other people are interested in this
tool, I could definitely start working through those samplesâ€¦

Actually, when the markdown output looks funny, often itâ€™s because the
input HTML is a bit off, e.g., `<b>Hello </b>world` comes out as `**Hello
**world`. Thatâ€™s something 2md could clean up automatically, and I might do
that some time, as well as taking a look at some parsing the styles, so
that some day `<span style="â€¦; font-weight: bold; â€¦">foo</span>` comes out
as `**foo**`.

This feels like the first project Iâ€™ve done thatâ€™s really, really easy for
other people to use, setup/installation-wise: just click a link and get
something interactive. For the ability to give people that, I will
definitely use more TypeScript in the future.

In case youâ€™re curious about time: it was about a week of full-time work to
get an initial version with good coverage of markdown features, including
nested lists. It took less than a day to get it running on the web, and
that was mostly dealing with tooling. Dealing with command-line speed
issues was under a day. Windows clipboard support by itself was close to
two days, and now talk preparation / article writing is getting close to
two weeks.

Relating back to the quote from Neal Ford on automation: instead of getting
bored adding markdown formatting over and over by hand, I learned a ton
automating the process, and Iâ€™m really, really happy about that. In fact
the hard part now is resisting the urge to simultaneously explore all the
new avenues this has opened up.

â€”Â Andrew.

</div>
